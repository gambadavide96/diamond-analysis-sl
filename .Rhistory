quote = "\"",
fileEncoding = "UTF-8")
### Transform Categorical Variables as factors
Diamonds$cut <- factor(Diamonds$cut,
levels = c("Fair", "Good", "Very Good", "Premium", "Ideal"))
Diamonds$color <- factor(Diamonds$color,
levels = c("J", "I", "H", "G", "F","E","D"))
Diamonds$clarity <- factor(Diamonds$clarity,
levels=c("I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"))
# no nan colums
colSums(is.na(Diamonds))
View(Diamonds)
detect_outlier <- function(x) {
Quantile1 <- quantile(x, probs=.25)
Quantile3 <- quantile(x, probs=.75)
IQR = Quantile3 - Quantile1
x > Quantile3 + (IQR*1.5) | x < Quantile1 - (IQR*1.5)
}
remove_outlier <- function(dataframe,columns=names(dataframe)) {
for (col in columns) {
dataframe <- dataframe[!detect_outlier(dataframe[[col]]), ]
}
print("Remove outliers")
print(dataframe)
}
Diamonds <- remove_outlier(Diamonds, c('carat', 'depth_percentage', 'table', 'price',
"length", 'width', "depth"))
#train and test indexes
train <- sample(nrow(Diamonds),floor(nrow(Diamonds)*0.7),replace = FALSE)
price_test <- Diamonds$price[-train]
#preparing data
#creating regressor (automatic handle categorical variables in dummy variables)
x <- model.matrix ( price ~ . +(length * width * depth) ,
Diamonds )[,-1]  #tutte le righe - la prima colonna (intercetta)
y <- Diamonds$price
View(x)
View(y)
y
kfold <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(y ~ poly ( . , i ) , data = x ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
df <- as.data.frame(x)
View(df)
for(i in 1:5) {
k_fit <- glm(y ~ poly ( . , i ) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(y ~ poly ( lenght:width , i ) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
k_fit <- glm(y ~ . , data = df ) #creo il modello di ordine i
summary(k_fit)
k_fit <- glm(y ~ poly(.,i) , data = df ) #creo il modello di ordine i
for(i in 1:5) {
k_fit <- glm(y ~ poly(length:width,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
kfold <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(y ~ poly(length:width,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , glm_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
kfold <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
anyNA(df$length)
k_fit <- glm(y ~ poly(length,2) , data = df ) #creo il modello di ordine i
k_fit
summary(k_fit)
k_fit$R
kfold <- rep (0 , 5)
kfold
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
poly_degrees <- 1:5
for(i in poly_degrees) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Auto , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
for(i in poly_degrees) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
kfold[ i ] <- cv.glm( Auto , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = df ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( df , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
View(df)
k_fit <- glm(y ~ poly(length,2) , data = df ) #creo il modello di ordine i
kfold[ 2 ] <- cv.glm( df , k_fit , K = 10)$delta[1]
kfold
k_fit <- glm(y ~ poly(length,2) , data = df ) #creo il modello di ordine i
kfold[ 2 ] <- cv.glm( df$length , k_fit , K = 10)$delta[1]
k_fit <- glm(y ~ poly(length,2) , data = df ) #creo il modello di ordine i
kfold[ 2 ] <- cv.glm( df , k_fit , K = 10)$delta[1]
k_fit <- glm(y ~ poly(carat,2) , data = df ) #creo il modello di ordine i
kfold[ 2 ] <- cv.glm( df , k_fit , K = 10)$delta[1]
kfold <- rep (0 , 5)
kfold
for(i in 1:5) {
k_fit <- glm(y ~ poly(length,i) , data = Diamonds ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Diamonds , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
#Cross-validation for Generalized Linear Models: cv.glm K = 10
cv_err <- cv.glm(Diamonds , glm_fit, K = 10)
#Cross-validation for Generalized Linear Models: cv.glm K = 10
cv_err <- cv.glm(Diamonds , k_fit, K = 10)
for(i in 1:5) {
k_fit <- lm(y ~ poly(length,i) , data = Diamonds ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Diamonds , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
k_fit <- glm(price ~ poly(length,i) , data = Diamonds ) #creo il modello di ordine i
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) , data = Diamonds ) #creo il modello di ordine i
summary(k_fit)
kfold[ i ] <- cv.glm( Diamonds , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
kfold
for(i in 1:5) {
k_fit <- glm(price ~ . , data = Diamonds ) #creo il modello di ordine i
kfold[ i ] <- cv.glm( Diamonds , k_fit , K = 10)$delta[1] #prendo il test MSE per quel modello
}
kfold
for(i in 1:5) {
k_fit <- glm(price ~ . , data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ . , data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
kfold_RMSE
################################################################################
############################### Validation
################################################################################
library(ISLR2)
set.seed(1) # seed for random number generaotr
#In this lab, we re-analyze the Wage data
library(ISLR2)
################################################################################
################ Polynomial Regression
################################################################################
# y = B0+B1*age+B2*age^2+B3*age^3+B4*age^4
fit <- lm(wage ~ poly(age , 4), data = Wage)
#The function returns a matrix whose columns are a basis of
#orthogonal polynomials, which essentially means that each column is a linear
#combination of the variables age, age^2, age^3 and age^4.
coef(summary(fit))
#However, we can also use poly() to obtain age, age^2, age^3 and age^4
#directly, if we prefer. We can do this by using the raw = TRUE argument to
#the poly() function.
fit2 <- lm(wage ~ poly(age , 4, raw = T), data = Wage)
coef(summary(fit2))
#This simply creates the polynomial basis functions on the fly, taking care
#to protect terms like age^2 via the wrapper function I()
fit2a <- lm(wage ~ age + I(age^2) + I(age^3) + I(age^4),
data = Wage)
coef(fit2a)
summary(fit2a)
#This does the same more compactly, using the cbind() function for building
#a matrix from a collection of vectors; any function call such as cbind() inside
#a formula also serves as a wrapper
fit2b <- lm(wage ~ cbind(age , age^2, age^3, age^4),data = Wage)
summary(fit2b)
View(Wage)
Diamonds <- read.table("diamonds.csv", header = TRUE,
sep = ",",
quote = "\"",
fileEncoding = "UTF-8")
### Transform Categorical Variables as factors
Diamonds$cut <- factor(Diamonds$cut,
levels = c("Fair", "Good", "Very Good", "Premium", "Ideal"))
Diamonds$color <- factor(Diamonds$color,
levels = c("J", "I", "H", "G", "F","E","D"))
Diamonds$clarity <- factor(Diamonds$clarity,
levels=c("I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"))
# no nan colums
colSums(is.na(Diamonds))
detect_outlier <- function(x) {
Quantile1 <- quantile(x, probs=.25)
Quantile3 <- quantile(x, probs=.75)
IQR = Quantile3 - Quantile1
x > Quantile3 + (IQR*1.5) | x < Quantile1 - (IQR*1.5)
}
remove_outlier <- function(dataframe,columns=names(dataframe)) {
for (col in columns) {
dataframe <- dataframe[!detect_outlier(dataframe[[col]]), ]
}
print("Remove outliers")
print(dataframe)
}
Diamonds <- remove_outlier(Diamonds, c('carat', 'depth_percentage', 'table', 'price',
"length", 'width', "depth"))
set.seed(1) # seed for random number generator
library(boot)
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) , data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
summary(k_fit)
coeff(k_fit)
coef(k_fit)
View(Diamonds)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+ poly(width,i) + carat + color + cut + clarity,
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
kfold_RMSE
summary(k_fit)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+ poly(width,i) + carat + color + cut + clarity
+poly(lenght*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+ poly(width,i) + carat + color + cut + clarity
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test MSE per quel modello
}
kfold_RMSE
summary(k_fit)
plot(1:10,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
plot(1:5,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
for(i in 1:10) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE <- rep (0 , 10)
for(i in 1:10) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
plot(1:5,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
plot(1:10,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
kfold_RMSE <- rep (0 , 8)
for(i in 1:10) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length * width * depth) , data = Diamonds,
subset = train)
train <- sample(nrow(Diamonds),floor(nrow(Diamonds)*0.7),replace = FALSE)
price_test <- Diamonds$price[-train]
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length * width * depth) , data = Diamonds,
subset = train)
summary(lm_model_2)
#Test RMSE
fitt_value_lm_2 = predict(lm_model_2,newdata = Diamonds[-train,])
lm_test_RMSE_2 = sqrt(mean((fitt_value_lm_2 - Diamonds$price[-train])^2))
lm_test_RMSE_2
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(length*width,i)
+poly(length*depth,i)
+poly(width*depth,i)
+poly(length*width*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
summary(k_fit)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity,
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
summary(k_fit)
kfold_RMSE
plot(1:10,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
plot(1:5,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
kfold_RMSE <- rep (0 , 10)
for(i in 1:10) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity,
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
kfold_RMSE <- rep (0 , 5)
for(i in 1:10) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity,
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length : width : depth) , data = Diamonds,
subset = train)
summary(lm_model_2)
#Test RMSE
fitt_value_lm_2 = predict(lm_model_2,newdata = Diamonds[-train,])
lm_test_RMSE_2 = sqrt(mean((fitt_value_lm_2 - Diamonds$price[-train])^2))
lm_test_RMSE_2
#preparing data
#creating regressor (automatic handle categorical variables in dummy variables)
x <- model.matrix ( price ~ . +(length : width : depth) ,
Diamonds )[,-1]  #tutte le righe - la prima colonna (intercetta)
View(x)
#Train model
lm_model_1 = lm(price ~ . , data = Diamonds,subset = train)
## Anova test per confrontare i due modelli di regressione lineare creati ##
anova(lm_model_1,lm_model_2)
#test RMSE
pred_err = (Diamonds$price- predict(lm_model_1,Diamonds))^2
test_rmse = sqrt(mean(pred_err[-train]))
#using predict() function
y_hat_lm = predict(lm_model_1,newdata = Diamonds[-train,])
lm_test_RMSE_1 = sqrt(mean((y_hat_lm - Diamonds$price[-train])^2))
lm_test_RMSE_1
test_rmse
lm_test_RMSE_2
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length * width * depth) , data = Diamonds,
subset = train)
#Test RMSE
fitt_value_lm_2 = predict(lm_model_2,newdata = Diamonds[-train,])
lm_test_RMSE_2 = sqrt(mean((fitt_value_lm_2 - Diamonds$price[-train])^2))
lm_test_RMSE_2
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(width*lenght*depth),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(width*length*depth),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
summary(k_fit)
kfold_RMSE
plot(1:5,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
kfold_RMSE
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length : width : depth) , data = Diamonds,
subset = train)
summary(lm_model_2)
## Anova test per confrontare i due modelli di regressione lineare creati ##
anova(lm_model_1,lm_model_2)
summary(k_fit)
kfold_RMSE <- rep (0 , 7)
for(i in 1:7) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(width*length*depth),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+poly(width,i) + carat + color + cut + clarity
+poly(width*length*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE <- rep (0 , 5)
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+carat + color + cut + clarity
+poly(width:length:depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
for(i in 1:5) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+carat + color + cut + clarity
+poly(width*length*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
summary(k_fit)
kfold_RMSE
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length : width : depth) , data = Diamonds,
subset = train)
##### Model with interaction terms #####
lm_model_2 = lm(price ~ . + (length:width:depth) , data = Diamonds,
subset = train)
summary(lm_model_2)
#Test RMSE
fitt_value_lm_2 = predict(lm_model_2,newdata = Diamonds[-train,])
lm_test_RMSE_2 = sqrt(mean((fitt_value_lm_2 - Diamonds$price[-train])^2))
lm_test_RMSE_2
kfold_RMSE
kfold_RMSE <- rep (0 , 7)
for(i in 1:7) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+carat + color + cut + clarity
+poly(width*length*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
set.seed(1) # seed for random number generator
kfold_RMSE <- rep (0 , 6)
for(i in 1:6) {
k_fit <- glm(price ~ poly(length,i) + poly(width,i) +
poly(depth,i) + poly(table,i) + poly(depth_percentage,i)
+carat + color + cut + clarity
+poly(width*length*depth,i),
data = Diamonds ) #creo il modello di ordine i
kfold_RMSE[ i ] <- sqrt(cv.glm( Diamonds , k_fit , K = 10)$delta[1]) #prendo il test RMSE per quel modello
}
kfold_RMSE
plot(1:6,kfold_RMSE,type = "b",col = "blue",
ylab = "CV error",
xlab = "Flexibility (poly degree)",
main = "Test error estimation")
